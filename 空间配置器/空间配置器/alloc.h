template<bool threads, int inst>//////inst 是预留的参数，以后用
class__DefaultAllocTemplate
{
public:
	enum{ __ALIGN = 8 }; //排列基准值（也是排列间隔）
	enum{ __MAX_BYTES = 128 }; //最大值
	enum{ __NFREELISTS = __MAX_BYTES / __ALIGN }; //排列链大小
	static size_t ROUND_UP(size_t bytes)
	{
		//对齐
		return((bytes + __ALIGN - 1) & ~(__ALIGN - 1));
	}
	static size_t FREELIST_INDEX(size_t bytes)
	{
		// bytes == 9
		// bytes == 8
		// bytes == 7
		return((bytes + __ALIGN - 1) / __ALIGN - 1);
	}
	union Obj
	{
		union Obj*_freeListLink; //指向下一个内存块的指针
		char _clientData[1]; /* The client sees this.*/
	};
	static Obj*volatile_freeList[__NFREELISTS]; //自由链表
	static char*_startFree; //内存池水位线开始
	static char*_endFree; //内存池水位线结束
	static size_t _heapSize; //从系统堆分配的总大小
	//获取大块内存插入到自由链表中
	static void*Refill(size_t n);
	//从内存池中分配大块内存
	static char*ChunkAlloc(size_t size, int&nobjs);
	static void*Allocate(size_t n);
	static void Deallocate(void*p, size_t n);
	static void*Reallocate(void*p, size_t old_sz, size_t new_sz);
};
//初始化全局静态对象
template<bool threads, int inst>
//加一个typename 使编译器相信这是一个可用的变量，否则需要初始化对象以后才能用
typename __DefaultAllocTemplate<threads, inst>::Obj*volatile __DefaultAllocTemplate<threads, inst>::_freeList[__DefaultAllocTemplate<threads, inst>::__NFREELISTS];
template<bool threads, int inst>
char*__DefaultAllocTemplate<threads, inst>::_startFree = 0;
template<bool threads, int inst>
char*__DefaultAllocTemplate<threads, inst>::_endFree = 0;
template<bool threads, int inst>
size_t __DefaultAllocTemplate<threads, inst>::_heapSize = 0;;


template<bool threads, int inst>
void*__DefaultAllocTemplate<threads, inst>::Refill(size_t n)
{
	__TRACE_DEBUG("(n:%u)\n", n);
	//
	//分配个n bytes的内存
	//如果不够则能分配多少分配多少
	//
	int nobjs = 20;
	char*chunk = ChunkAlloc(n, nobjs);
	//如果只分配到一块，则直接这块内存。
	if (nobjs == 1)
		return chunk;
	Obj*result, *cur;
	size_t index = FREELIST_INDEX(n);
	result = (Obj*)chunk;
	//把剩余的块链接到自由链表上面
	cur = (Obj*)(chunk + n);
	_freeList[index] = cur
	//之所以从2开始：0被拿走用了，1已经被挂在上面了
	for (int i = 2; i < nobjs; ++i)
	{
		cur->_freeListLink = (Obj*)(chunk + n*i);
		cur = cur->_freeListLink;
	}
	cur->_freeListLink = NULL;
	return result;
}


template<bool threads, int inst>
char*__DefaultAllocTemplate<threads, inst>::ChunkAlloc(size_t size, int&nobjs)
{
	__TRACE_DEBUG("(size: %u, nobjs: %d)\n", size, nobjs);
	char*result;
	size_t bytesNeed = size*nobjs;
	size_t bytesLeft = _endFree - _startFree;
	//
	// 1.内存池中的内存足够，bytesLeft>=bytesNeed，则直接从内存池中取。
	// 2.内存池中的内存不足，但是够一个bytesLeft >= size，则直接取能够取出来。
	// 3.内存池中的内存不足，则从系统堆分配大块内存到内存池中。
	//
	if (bytesLeft >= bytesNeed)
	{
		__TRACE_DEBUG("内存池中内存足够分配%d个对象\n", nobjs);
		result = _startFree;
		_startFree += bytesNeed;
	}
	else if(bytesLeft >= size)
	{
		__TRACE_DEBUG("内存池中内存不够分配%d个对象，只能分配%d个对象\n", nobjs, bytesLeft / size);
		result = _startFree;
		nobjs = bytesLeft / size;
		_startFree += nobjs*size;
	}
	else
	{
		//若内存池中还有小块剩余内存，则将它头插到合适的自由链表
		if (bytesLeft > 0)
		{
			size_t index = FREELIST_INDEX(bytesLeft);
			((Obj*)_startFree)->_freeListLink = _freeList[index];
			_freeList[index] = (Obj*)_startFree;
			_startFree = NULL;
			__TRACE_DEBUG("将内存池中剩余的空间，分配给freeList[%d]\n", index);
		}
		//从系统堆分配两倍+已分配的heapSize/8的内存到内存池中
		size_t bytesToGet = 2 * bytesNeed + ROUND_UP(_heapSize >> 4);
		_startFree = (char*)malloc(bytesToGet);
		__TRACE_DEBUG("内存池空间不足，系统堆分配%u bytes内存\n", bytesToGet);
		//
		//【无奈之举】
		//如果在系统堆中内存分配失败，则尝试到自由链表中更大的节点中分配
		//
		if (_startFree == NULL)
		{
			/////这里有一个疑问：为何从size开始，而不从size+1开始
			__TRACE_DEBUG("系统堆已无足够，无奈之下，智能到自由链表中看看\n");
			for (int i = size; i <= __MAX_BYTES; i += __ALIGN)
			{
				Obj*head = _freeList[FREELIST_INDEX(size)];
				if (head)
				{
					_startFree = (char*)head;
					head = head->_freeListLink;
					_endFree = _startFree + i;
					return ChunkAlloc(size, nobjs);
				}
			}
			//
			//【山穷水尽，最后一根稻草】
			//自由链表中也没有分配到内存，则再到一级配置器中分配内存，
			//一级配置器中可能有设置的处理内存，或许能分配到内存。
			//

			//为什么这么说：以及空间配置器中设置了句柄
			__TRACE_DEBUG("系统堆和自由链表都已无内存，一级配置器做最后一根稻草\n");
			_startFree = (char*)MallocAlloc::Allocate(bytesToGet);
		}
		//从系统堆分配的总字节数。（可用于下次分配时进行调节）
		_heapSize += bytesToGet;
		_endFree = _startFree + bytesToGet;
		//递归调用获取内存
		return ChunkAlloc(size, nobjs);
	}
	return result;
}


template<bool threads, int inst>
void*__DefaultAllocTemplate<threads, inst>::Allocate(size_t n)
{
	__TRACE_DEBUG("(n: %u)\n", n);
	//
	//若n > __MAX_BYTES则直接在一级配置器中获取
	//否则在二级配置器中获取
	//
	if (n > __MAX_BYTES)
	{
		return MallocAlloc::Allocate(n);
	}
	size_t index = FREELIST_INDEX(n);
	void*ret = NULL;
	//
	// 1.如果自由链表中没有内存则通过Refill进行填充
	// 2.如果自由链表中有则直接返回一个节点块内存
	// ps:多线程环境需要考虑加锁
	//
	Obj*head = _freeList[index];
	if (head == NULL)
	{
		return Refill(ROUND_UP(n));
	}
	else
	{
		__TRACE_DEBUG("自由链表取内存:_freeList[%d]\n", index);
		_freeList[index] = head->_freeListLink;
		return head;
	}
}
template<bool threads, int inst>
void __DefaultAllocTemplate<threads, inst>::Deallocate(void*p, size_t n)
{
	__TRACE_DEBUG("(p:%p, n: %u)\n", p, n);
	//
	//若n > __MAX_BYTES则直接归还给一级配置器
	//否则在放回二级配置器的自由链表
	//
	if (n > __MAX_BYTES)
	{
		MallocAlloc::Deallocate(p, n);
	}
	else
	{
		// ps:多线程环境需要考虑加锁
		size_t index = FREELIST_INDEX(n);
		//头插回自由链表
		Obj*tmp = (Obj*)p;
		tmp->_freeListLink = _freeList[index];
		_freeList[index] = tmp;
	}
}
template<bool threads, int inst>
void*__DefaultAllocTemplate<threads, inst>::Reallocate(void*p, size_t old_sz, size_t new_sz)
{
	void*result;
	size_t copy_sz;
	if (old_sz > (size_t)__MAX_BYTES&&new_sz > (size_t)__MAX_BYTES) {
		return(realloc(p, new_sz));
	}
	if (ROUND_UP(old_sz) == ROUND_UP(new_sz))
		return p;
	result = Allocate(new_sz);
	copy_sz = new_sz > old_sz ? old_sz : new_sz;
	memcpy(result, p, copy_sz);
	Deallocate(p, old_sz);
	return result;
}
// 通过__TRACE_DEBUG 做白盒测试
// 测试内存池的一级、二级配置器功能
void Test1()
{
	// 测试调用一级配置器分配内存
	cout << " 测试调用一级配置器分配内存 " << endl;
	char*p1 = SimpleAlloc< char, Alloc>::Allocate(129);
	SimpleAlloc<char, Alloc>::Deallocate(p1, 129);
	// 测试调用二级配置器分配内存
	cout << " 测试调用二级配置器分配内存 " << endl;
	char*p2 = SimpleAlloc< char, Alloc>::Allocate(128);
	char*p3 = SimpleAlloc< char, Alloc>::Allocate(128);
	char*p4 = SimpleAlloc< char, Alloc>::Allocate(128);
	char*p5 = SimpleAlloc< char, Alloc>::Allocate(128);
	SimpleAlloc<char, Alloc>::Deallocate(p2, 128);
	SimpleAlloc<char, Alloc>::Deallocate(p3, 128);
	SimpleAlloc<char, Alloc>::Deallocate(p4, 128);
	SimpleAlloc<char, Alloc>::Deallocate(p5, 128);
	for (int i = 0; i < 21; ++i)
	{
		printf(" 测试第%d次分配 \n", i + 1);
		char*p = SimpleAlloc< char, Alloc>::Allocate(128);
	}
}
// 测试特殊场景
void Test2()
{
	cout << " 测试内存池空间不足分配个 " << endl;
	// 8*20->8*2->320
	char*p1 = SimpleAlloc< char, Alloc>::Allocate(8);
	char*p2 = SimpleAlloc< char, Alloc>::Allocate(8);
	cout << " 测试内存池空间不足，系统堆进行分配 " << endl;
	char*p3 = SimpleAlloc< char, Alloc>::Allocate(12);
}
// 测试系统堆内存耗尽的场景
void Test3()
{
	cout << " 测试系统堆内存耗尽 " << endl;
	SimpleAlloc<char, Alloc>::Allocate(1024 * 1024 * 1024);
	//SimpleAlloc<char, Alloc>::Allocate(1024*1024*1024);
	SimpleAlloc<char, Alloc>::Allocate(1024 * 1024);
	// 不好测试，说明系统管理小块内存的能力还是很强的。
	for (int i = 0; i < 100000; ++i)
	{
		char*p1 = SimpleAlloc< char, Alloc>::Allocate(128);
	}
}